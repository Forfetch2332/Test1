{
  "title": "Форматы данных: JSON/CSV/XML",
  "summary": "Краткий обзор трёх распространённых форматов обмена данными: JSON, CSV и XML — как читать, писать и когда выбирать каждый из них.",
  "text": [
    "JSON (JavaScript Object Notation) — лёгкий текстовый формат для представления структурированных данных в виде объектов (словарей) и массивов (списков). Широко используется для API, конфигураций и сериализации. В Python работает модуль json для сериализации и десериализации.",
    "CSV (Comma Separated Values) — табличный текстовый формат, где каждая строка представляет запись, а поля разделяются запятой или другим разделителем. Удобен для экспорта/импорта таблиц, электронных таблиц и простых датасетов. Для работы в Python есть модуль csv, который корректно обрабатывает кавычки, экранирование и разные разделители.",
    "XML (eXtensible Markup Language) — древний и гибкий формат на основе тегов, пригодный для иерархических данных и документов с метаданными. Для простых задач в Python достаточно xml.etree.ElementTree; для более сложных — lxml. XML требует внимательного парсинга и часто более громоздок по сравнению с JSON.",
    "Когда выбирать формат: JSON — универсален для структурированных данных и API; CSV — лучший выбор для плоских таблиц и совместимости с Excel; XML — если нужны строгие схемы (XSD), атрибуты и совместимость с существующими XML-инфраструктурами.",
    "Безопасность и валидация: при парсинге внешних данных избегай выполнения произвольного кода; стандартный json безопасен, а для XML избегай уязвимостей XXE (используй безопасные парсеры или отключай внешние сущности).",
    "Производительность и память: csv и json обычно быстрее и компактнее для большинства случаев; XML занимает больше места и требует больше CPU для парсинга. Для больших объёмов данных используйте стриминговый парсинг (iterparse для XML, reader для csv, incremental json парсеры при необходимости).",
    "Художественный образ: представь JSON как аккуратно оформленный каталог книг (ключ→значение), CSV — стопку карточек в ящике (таблица), а XML — архитектурный план с множеством заметок и аннотаций (теги и атрибуты)."
  ],
  "example": "import json\nimport csv\nimport xml.etree.ElementTree as ET\nfrom pathlib import Path\n\n# JSON: запись и чтение\ndata = {'name': 'Анна', 'age': 30, 'skills': ['python', 'testing']}\nwith open('data.json', 'w', encoding='utf-8') as f:\n    json.dump(data, f, ensure_ascii=False, indent=2)\nwith open('data.json', 'r', encoding='utf-8') as f:\n    loaded = json.load(f)\nprint('JSON loaded:', loaded)\n\n# CSV: запись и чтение табличных данных\nrows = [['name', 'age'], ['Анна', '30'], ['Максим', '22']]\nwith open('data.csv', 'w', newline='', encoding='utf-8') as f:\n    writer = csv.writer(f)\n    writer.writerows(rows)\nwith open('data.csv', 'r', encoding='utf-8') as f:\n    reader = csv.reader(f)\n    for row in reader:\n        print('CSV row:', row)\n\n# XML: создание и парсинг\nroot = ET.Element('people')\np = ET.SubElement(root, 'person', attrib={'id': '1'})\nET.SubElement(p, 'name').text = 'Анна'\nET.SubElement(p, 'age').text = '30'\n tree = ET.ElementTree(root)\n tree.write('data.xml', encoding='utf-8', xml_declaration=True)\n# чтение\ntree = ET.parse('data.xml')\nroot = tree.getroot()\nfor person in root.findall('person'):\n    name = person.find('name').text\n    age = person.find('age').text\n    print('XML person:', name, age)",
  "notes": [
    {
      "hint": "Для JSON используйте ensure_ascii=False и indent при записи, если хотите читабельный файл с юникодом."
    },
    {
      "hint": "При работе с CSV всегда открывайте файл с newline='' и используйте модуль csv, чтобы корректно обрабатывать кавычки и разделители."
    },
    {
      "hint": "XML-парсинг: избегайте небезопасных парсеров и отключайте внешние сущности при парсинге данных из ненадёжных источников."
    },
    {
      "hint": "Для больших файлов используйте стриминг: csv.reader читает построчно; для XML — ET.iterparse; для JSON используйте потоковые парсеры (ijson) при необходимости."
    },
    {
      "hint": "CSV не хранит типы данных: при чтении приводите значения к нужным типам вручную (int, float, bool)."
    },
    {
      "hint": "Для схемной валидации JSON используйте JSON Schema; для XML — XSD. Они помогут гарантировать структуру входных данных."
    },
    {
      "hint": "При обмене данными между системами согласуйте кодировку (UTF-8) и формат даты/времени, чтобы избежать некорректной интерпретации."
    },
    {
      "hint": "Если нужна человеко‑читаемая и компактная сериализация с возможностью комментариев — рассмотрите форматы вроде YAML, но помните об их особенностях безопасности."
    }
  ]
}
