{
  "title": "Простые CLI-приложения (argparse)",
  "summary": "Создание простых командных утилит на Python с использованием argparse: парсинг аргументов, флаги, подкоманды и базовые практики для удобного интерфейса командной строки.",
  "text": [
    "CLI (command-line interface) — удобный способ взаимодействия с программой через терминал. Простые утилиты часто принимают аргументы и флаги, выполняют задачу и возвращают результат. Python предоставляет модуль argparse для стандартного, понятного и документируемого парсинга аргументов.",
    "argparse позволяет объявлять позиционные аргументы и опциональные флаги (с префиксами -/--), задавать типы, значения по умолчанию, описания и аргументы с множественным повторением. Модуль автоматически генерирует помощь (--help) и сообщает об ошибках ввода.",
    "Позиционные аргументы обязательны и определяют входные данные (например, имя файла). Опциональные аргументы начинаются с '-' или '--' и обычно используются для настроек (уровень логирования, режим работы). Для булевых флагов удобно использовать action='store_true'.",
    "argparse поддерживает подкоманды через subparsers: это позволяет создавать многофункциональные утилиты с командами типа git add / git commit. Каждая подкоманда имеет свой парсер и набор аргументов.",
    "Для преобразования аргументов в нужные типы используйте параметр type (int, float, pathlib.Path и т. п.). Валидацию можно добавить вручную в коде после парсинга или через кастомные типы/функции для параметра type.",
    "При разработке CLI полезно возвращать понятные коды выхода (0 — успех, ненулевые — ошибка) и печатать сообщения в stderr для ошибок. Логирование можно настроить через модуль logging и привязывать уровень логирования к флагам (например, --verbose).",
    "Художественный образ: представь CLI как официанта в кафе: клиент (пользователь) даёт заказ (аргументы), официант уточняет опции (флаги), на кухне готовят блюдо (выполняется логика), и официант возвращает результат или предупреждает о проблемах.",
    "Автотестирование командной строки удобно делать через pytest и встроенные фикстуры (capsys) или с помощью модуля subprocess для интеграционных проверок. Документируй поведение --help и примеры использования в README."
  ],
  "example": "import argparse\nimport sys\nfrom pathlib import Path\n\ndef count_lines(path: Path, ignore_empty: bool = False) -> int:\n    with path.open('r', encoding='utf-8') as f:\n        lines = f.readlines()\n    if ignore_empty:\n        lines = [l for l in lines if l.strip()]\n    return len(lines)\n\ndef build_parser():\n    parser = argparse.ArgumentParser(description='Подсчёт строк в текстовом файле')\n    parser.add_argument('file', type=Path, help='путь к файлу')\n    parser.add_argument('-i', '--ignore-empty', action='store_true', help='игнорировать пустые строки')\n    parser.add_argument('-v', '--verbose', action='store_true', help='подробный вывод')\n    return parser\n\ndef main(argv=None):\n    argv = argv if argv is not None else sys.argv[1:]\n    parser = build_parser()\n    args = parser.parse_args(argv)\n\n    if args.verbose:\n        print(f'Файл: {args.file}  Игнорировать пустые: {args.ignore_empty}')\n\n    try:\n        total = count_lines(args.file, ignore_empty=args.ignore_empty)\n    except FileNotFoundError:\n        print(f'Файл не найден: {args.file}', file=sys.stderr)\n        return 1\n    except Exception as e:\n        print(f'Ошибка: {e}', file=sys.stderr)\n        return 2\n\n    print(f'Количество строк: {total}')\n    return 0\n\nif __name__ == '__main__':\n    raise SystemExit(main())",
  "notes": [
    {
      "hint": "Используй argparse.ArgumentParser для описания интерфейса и автоматического формирования --help."
    },
    {
      "hint": "Для булевых флагов применяй action='store_true' или action='store_false'."
    },
    {
      "hint": "Разделяй логику парсинга и бизнес‑логику: функция main должна быть тонкой оболочкой вокруг чистых функций."
    },
    {
      "hint": "Подкоманды (subparsers) удобны для многофункциональных утилит; каждая подкоманда получает собственный парсер."
    },
    {
      "hint": "Возвращай осмысленные коды выхода и выводи ошибки в stderr, чтобы пользователи и скрипты могли корректно реагировать."
    },
    {
      "hint": "Для путей файлов используйте pathlib.Path как тип аргумента; это облегчает работу с файловой системой."
    },
    {
      "hint": "Тестируй CLI через pytest, передавая argv в функцию main или используя subprocess для интеграционных сценариев."
    },
    {
      "hint": "Документируй примеры использования в --help и README: пользователю проще начать с готовых команд."
    }
  ]
}
