{
  "title": "Декораторы",
  "summary": "Понимание декораторов как функций высшего порядка: как оборачивать функции, добавлять поведение, сохранять метаданные и создавать параметризованные декораторы.",
  "text": [
    "Декоратор в Python — это шаблон, который позволяет «надеть» дополнительное поведение на функцию или метод, не меняя её исходный код. Технически декоратор — это функция, принимающая другую функцию и возвращающая новую функцию. Это похоже на аксессуар, который вы надеваете на одежду: форма остаётся та же, но добавляется новая функция.",
    "Базовая форма декоратора выглядит так: декоратор принимает функцию func, внутри определяет wrapper (обёртку), которая выполняет дополнительную логику до или после вызова исходной функции, а затем возвращает wrapper. При применении синтаксис @decorator над определением функции эквивалентен присваиванию: f = decorator(f).",
    "Простой пример: логирующий декоратор, который печатает время вызова и аргументы функции. Обёртка получает *args и **kwargs, вызывает исходную функцию и возвращает её результат. Использование универсальных параметров (*args, **kwargs) делает декоратор совместимым с функциями любой сигнатуры.",
    "Важно сохранять метаданные исходной функции (имя, строку документации) при обёртывании. Для этого используется functools.wraps — декоратор, который копирует __name__, __doc__ и другие атрибуты от оригинальной функции к обёртке. Без wraps отладка и документация становятся менее удобными, потому что имя функции будет заменено на имя wrapper.",
    "Декораторы можно вкладывать: несколько @декораторов применяются сверху вниз, при этом фактически вызывается цепочка обёрток. Порядок важен: верхний декоратор оборачивает результат нижнего.",
    "Иногда нужно параметризовать декоратор — сделать так, чтобы он принимал аргументы (например, уровень логирования). Для этого создают фабрику декораторов: внешняя функция принимает параметры и возвращает сам декоратор, который затем возвращает wrapper. Внешняя функция запускается при создании декоратора, а wrapper — при каждом вызове декорируемой функции.",
    "Декораторы работают не только с функциями, но и с методами классов. При декорировании методов нужно учитывать, как Python передаёт self; обычно всё работает одинаково, если декоратор написан с учётом *args и **kwargs.",
    "Можно реализовать декоратор как класс, реализующий __call__. Это полезно, когда нужен сохранённый внутренний состояние между вызовами (например, счётчик вызовов) без использования глобальных переменных.",
    "Художественный образ: представь функцию как актёра на сцене. Декоратор — режиссёр и костюмер одновременно: он может добавить музыки перед выходом актёра (логирование), слегка изменить реплики (валидация аргументов) или посчитать аплодисменты после выхода (сбор статистики), при этом сам актёр остаётся тем же.",
    "Декораторы — мощный инструмент для разделения ответственностей: логирование, проверка прав доступа, кеширование, валидация, измерение времени выполнения и т. п. Главное — не злоупотреблять: если декораторов слишком много или они делают сложные побочные эффекты, код может стать трудным для понимания."
  ],
  "example": "from functools import wraps\nimport time\n\n# Простой логирующий декоратор\ndef log_calls(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Вызов {func.__name__} с args={args} kwargs={kwargs}\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__} вернула {result}\")\n        return result\n    return wrapper\n\n@log_calls\ndef add(a, b):\n    return a + b\n\nprint(add(2, 3))\n\n# Параметризованный декоратор: замер времени с уровнем логирования\ndef timed(level='info'):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            start = time.time()\n            result = func(*args, **kwargs)\n            elapsed = time.time() - start\n            if level == 'debug':\n                print(f\"[DEBUG] {func.__name__} выполнена за {elapsed:.6f} сек\")\n            else:\n                print(f\"{func.__name__}: {elapsed:.6f} сек\")\n            return result\n        return wrapper\n    return decorator\n\n@timed(level='debug')\ndef compute(n):\n    s = 0\n    for i in range(n):\n        s += i*i\n    return s\n\nprint(compute(10000))\n\n# Декоратор как класс: счётчик вызовов\nclass CallCounter:\n    def __init__(self, func):\n        wraps(func)(self)\n        self.func = func\n        self.count = 0\n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"Вызов #{self.count} функции {self.func.__name__}\")\n        return self.func(*args, **kwargs)\n\n@CallCounter\ndef greet(name):\n    return f\"Привет, {name}!\"\n\nprint(greet('Максим'))\nprint(greet('Анна'))",
  "notes": [
    {
      "hint": "Всегда используйте functools.wraps внутри обёртки, чтобы сохранить __name__, __doc__ и другие атрибуты оригинальной функции."
    },
    {
      "hint": "Декоратор должен принимать *args и **kwargs в обёртке, чтобы корректно работать с любыми сигнатурами функций."
    },
    {
      "hint": "Параметризованные декораторы — это функция, возвращающая декоратор: def outer(params): def decorator(func): ... return decorator."
    },
    {
      "hint": "Порядок применения нескольких декораторов важен: внешний (верхний в синтаксисе @) оборачивает результат внутреннего."
    },
    {
      "hint": "Если у декоратора есть побочные эффекты (логирование, кеширование), документируйте это в __doc__ или в комментариях, чтобы другие разработчики знали о поведении."
    },
    {
      "hint": "Для сохранения состояния между вызовами удобно реализовать декоратор как класс с методом __call__."
    },
    {
      "hint": "Не используйте декораторы для сложной бизнес‑логики: их задача — кросс‑срезовые заботы (cross‑cutting concerns), такие как логирование, кеширование, проверка прав доступа и т. п."
    },
    {
      "hint": "Тщательно тестируйте декораторы: они влияют на все декорируемые функции, и баги в декораторе могут быть массовыми."
    }
  ]
}
