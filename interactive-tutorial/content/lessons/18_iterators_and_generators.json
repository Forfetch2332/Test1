{
  "title": "Итераторы, генераторы, itertools",
  "summary": "Понимание протокола итераторов в Python, создание ленивых последовательностей с помощью генераторов и практическое знакомство с инструментами модуля itertools для работы с итерациями.",
  "text": [
    "Итерация — это процесс последовательного обхода элементов коллекции. В Python за это отвечает протокол итераторов: объект считается итерируемым, если у него есть метод __iter__(), возвращающий итератор; итератор — объект с методом __next__(), который возвращает следующий элемент и возбуждает StopIteration, когда элементы закончились. Именно этот механизм позволяет использовать for, tuple(), list() и другие конструкции для обхода данных.",
    "Итерируемые объекты и итераторы различаются: список — итерируемый (он создаёт новый итератор при каждом вызове iter()), а сам итератор — это объект, который продвигает «курсор» по коллекции и один раз проходит данные. После того как итератор исчерпан, повторный вызов next() сразу выдаст StopIteration, а повторный for по тому же списку создаст новый итератор и пройдёт элементы заново.",
    "Генераторы — это удобный способ объявить итератор без ручного написания класса. С помощью ключевого слова yield функция превращается в генератор: при каждом вызове yield функция приостанавливается, а её локальное состояние сохраняется. Генераторы ленивы: они вычисляют элементы по мере запроса, не храня все результаты в памяти. Это полезно для работы с большими или бесконечными последовательностями.",
    "Синтаксис прост: вместо return пишем yield. Пример: генератор, который выдаёт квадраты чисел по требованию — def squares(n): for i in range(n): yield i*i. Вызывающий код получает объект-генератор и извлекает значения через next() или в цикле for.",
    "Generator expression — компактная форма генератора в круглых скобках, похожая на list comprehension, но ленивый и не резервирует память для всего результата. Пример: (x*x for x in range(1000000)). Такой объект удобно передавать в функции, которые потребляют итераторы (sum, any, for и т.д.).",
    "Модуль itertools — набор оптимизированных инструментов для композиции итераторов. Он содержит простые генераторы (count, cycle, repeat), комбинирующие функции (chain, zip_longest), фильтрующие и оконные операторы (islice, compress, takewhile, dropwhile), а также комбинаторные утилиты (product, permutations, combinations). itertools полезен, когда нужно строить сложные конвейеры обработки данных без копирования коллекций в память.",
    "Практический совет: используйте генераторы и itertools, когда работаете с потоками данных, логами, большими файлами или при создании вычислений, где важно откладывать работу до момента необходимости. Но помните: генераторы одноразовые — после исчерпания их состояние уходит, и надо заново создать объект, если нужен повторный проход.",
    "Художественный образ: представь итератор как конвейер в мастерской. Итерируемый объект — это склад деталей. Итератор — тележка, которая выезжает на склад и последовательно доставляет детали. Генератор — автоматическая мини-станция, которая на лету формирует детали по запросу, а itertools — набор конвейерных модулей, которые можно комбинировать, чтобы построить сложную фабрику обработки данных."
  ],
  "example": "# Пример: простой итератор через класс\nclass CountUp:\n    def __init__(self, limit):\n        self.current = 0\n        self.limit = limit\n    def __iter__(self):\n        return self\n    def __next__(self):\n        if self.current >= self.limit:\n            raise StopIteration\n        value = self.current\n        self.current += 1\n        return value\n\nfor x in CountUp(5):\n    print(x)\n\n# Пример: генератор-функция (лениво выдаёт квадраты)\ndef squares(n):\n    for i in range(n):\n        yield i * i\n\ngen = squares(5)\nprint(next(gen))  # 0\nprint(list(gen))  # [1, 4, 9, 16]\n\n# Generator expression\ngen_expr = (x * x for x in range(6))\nprint(sum(gen_expr))\n\n# itertools — несколько полезных примеров\nimport itertools\n# count: бесконечная последовательность 0,1,2,... (осторожно)\nfor i in itertools.islice(itertools.count(0), 5):\n    print('count', i)\n# chain объединяет несколько итерируемых\nprint(list(itertools.chain([1,2], ['a','b'])))\n# combinations — все пары из списка\nprint(list(itertools.combinations([1,2,3], 2)))",
  "notes": [
    {
      "hint": "Итератор должен реализовывать методы __iter__() (возвращает self или новый итератор) и __next__() (возвращает следующий элемент или вызывает StopIteration)."
    },
    {
      "hint": "Генераторы — более простой способ создать итератор: используйте yield вместо ручной реализации __next__."
    },
    {
      "hint": "Генераторные выражения в круглых скобках ленивы и экономят память по сравнению со списковыми выражениями."
    },
    {
      "hint": "Модуль itertools содержит инструменты для бесконечных последовательностей (count, cycle), оконного доступа (islice), объединения (chain) и комбинаторики (product, permutations, combinations)."
    },
    {
      "hint": "islice позволяет взять срез из потенциально бесконечного итератора: itertools.islice(it, start, stop, step)."
    },
    {
      "hint": "После исчерпания итератора или генератора потребуется создать новый объект для повторной итерации."
    },
    {
      "hint": "Используйте itertools для построения эффективных конвейеров обработки данных без лишних копий коллекций в памяти."
    },
    {
      "hint": "Будь внимателен с бесконечными итераторами (count, cycle): всегда ограничивай их с помощью islice или условия, иначе программа не остановится."
    }
  ]
}
