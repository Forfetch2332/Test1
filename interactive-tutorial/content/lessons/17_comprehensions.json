{
  "title": "Генераторы списков слов множеств",
  "summary": "Понимание и использование генераторов списков, словарей и множеств: компактное создание коллекций, фильтрация и вложенные выражения.",
  "text": [
    "Генераторы (comprehensions) — это лаконичный и выразительный способ создавать коллекции в Python. Они позволяют записать создание списка, множества или словаря в одну строку, сохранив при этом читаемость. Генераторы помогают заменить привычные циклы for + append более компактными и часто более эффективными конструкциями.",
    "Синтаксис list comprehension выглядит так: [выражение for элемент in последовательность if условие]. Пример: [x * 2 for x in range(5)] создаёт список [0, 2, 4, 6, 8]. Тут выражение x * 2 применяется ко всем элементам, проходящим через цикл, а опциональная часть if позволяет фильтровать значения.",
    "Set comprehension похож на list comprehension, но создаёт множество (уникальные элементы) и записывается с фигурными скобками: {выражение for элемент in последовательность if условие}. Например, {x % 2 for x in range(10)} даст множество {0, 1}. Порядок при выводе множества неопределённый.",
    "Dict comprehension создаёт словарь в виде {ключ_выражение: значение_выражение for элемент in последовательность if условие}. Пример: {x: x * x for x in range(5)} даст {0:0, 1:1, 2:4, 3:9, 4:16}. Это удобный способ преобразовать последовательность в карту ключ→значение.",
    "В генераторах можно использовать условную фильтрацию через if, а также тернарные выражения внутри самого выражения: [x if x % 2 == 0 else -x for x in range(6)] вернёт [0, -1, 2, -3, 4, -5]. Тернарный оператор позволяет менять результат выражения в зависимости от условий.",
    "Генераторы поддерживают вложенность: можно имитировать двойной цикл for внутри одной строки. Например, [(i, j) for i in range(3) for j in range(2)] создаёт список кортежей пар (i, j). Вложенные генераторы применимы, но при чрезмерной вложенности код теряет читаемость.",
    "Генераторы часто эффективнее по коду и читаемее, но не всегда — если логика внутри сложная или требуется много побочных эффектов (print, запись в файл), лучше использовать явный цикл. Генераторы предназначены для чистого преобразования коллекций.",
    "Если нужен ленивый (поэлементный) генератор, используется generator expression в круглых скобках: (x * x for x in range(1000000)). Такой объект не хранит все элементы в памяти и вычисляет их по запросу — полезно для больших объёмов данных.",
    "Художественный образ: представь генератор как мельницу, в которую ты подаёшь зерно (исходную коллекцию), указываешь помол (выражение) и сито (условие), а на выходе получаешь аккуратно отсортированную муку (готовую коллекцию). Всё компактно и эффективно."
  ],
  "example": "# List comprehension: квадраты чётных чисел\nsquares = [x * x for x in range(10) if x % 2 == 0]\nprint(squares)  # [0, 4, 16, 36, 64]\n\n# Set comprehension: уникальные остатки от деления\nremainders = {x % 3 for x in range(10)}\nprint(remainders)  # {0, 1, 2}\n\n# Dict comprehension: отображение числа -> строка\nnum_to_str = {x: str(x) for x in range(5)}\nprint(num_to_str)  # {0: '0', 1: '1', 2: '2', 3: '3', 4: '4'}\n\n# Вложенный генератор: пары (i, j)\npairs = [(i, j) for i in range(3) for j in range(2)]\nprint(pairs)  # [(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)]\n\n# Ленивый генератор (generator expression)\nsq_gen = (x * x for x in range(5))\nfor val in sq_gen:\n    print(val)",
  "notes": [
    {
      "hint": "Используй list/set/dict comprehension для простых преобразований и фильтрации; они делают код компактнее и часто понятнее."
    },
    {
      "hint": "Не перегружай генераторы сложной логикой: если внутри много условий и побочных эффектов, перепиши на явный цикл для читаемости."
    },
    {
      "hint": "Память: list comprehension создаёт весь результат в памяти; для больших наборов используй generator expression в круглых скобках."
    },
    {
      "hint": "Порядок операций: for читается слева направо. В выражении [f(x, y) for x in A for y in B if cond(x, y)] сначала выполняются вложенные циклы, затем фильтр."
    },
    {
      "hint": "В dict comprehension ключи должны быть уникальными. При повторении ключа последнее значение перезапишет предыдущее."
    },
    {
      "hint": "Для сложных преобразований можно комбинировать map/filter с генераторами, но предпочитай генераторы для простоты и читаемости."
    },
    {
      "hint": "Используй скобки правильно: [] для списка, {} для множества и словаря (для словаря — пара ключ:значение внутри {})."
    },
    {
      "hint": "Генераторы — отличное средство для быстрой фильтрации дубликатов: list({x for x in seq}) вернёт уникальные элементы (порядок будет неопределён)."
    }
  ]
}
