{
  "title": "Тестирование: unittest pytest базовый обзор",
  "summary": "Введение в модульное тестирование на Python: зачем тестировать, как писать простые тесты с unittest и pytest, запуск и базовые практики для надёжного кода.",
  "text": [
    "Тестирование — это привычка защищать изменения: тесты подтверждают, что код делает то, что от него ожидают, и сигнализируют, если что‑то ломается после правок. Хороший набор тестов даёт уверенность и ускоряет разработку.",
    "Типичный набор тестов включает модульные (unit) тесты — проверка отдельных функций и классов, интеграционные — проверка взаимодействия компонентов, и системные — проверка приложения в целом. В этом файле сосредоточимся на базовых модульных практиках.",
    "unittest — встроенный в стандартную библиотеку фреймворк, вдохновлённый xUnit. Тесты в unittest оформляются как классы, унаследованные от unittest.TestCase, и методы‑тесты начинаются с test_. Внутри используют методы-утверждения (assertEqual, assertTrue, assertRaises и другие).",
    "pytest — популярный внешний фреймворк, более лаконичный и гибкий. Он поддерживает простые функции‑тесты без классов, мощные фикстуры для настройки контекста, параметризацию тестов и удобные плагины. Pytest делает тесты короче и читаемее.",
    "Базовый рабочий цикл: написать тесты, запустить их (python -m unittest discover или pytest), исправить найденные ошибки, затем повторить. Автозапуск тестов при сохранении файлов с помощью watch‑инструментов ускоряет цикл разработки.",
    "Удобные практики: держать тесты рядом с кодом в папке tests или отдельно в тестовом пакете; давать тестовым функциям понятные имена; проверять один аспект поведения в каждом тесте; использовать фикстуры/настройку для подготовки и очистки состояния.",
    "Mocking и заглушки позволяют изолировать тестируемый модуль от внешних зависимостей (сеть, БД, файловая система). В unittest есть unittest.mock, в pytest тот же модуль можно использовать совместно с фикстурами. Мока держат тесты быстрыми и детерминированными.",
    "Параметризация тестов (pytest.mark.parametrize или subTest в unittest) помогает проверить одно и то же поведение на множестве входных данных, не дублируя код тестов.",
    "Художественный образ: тест — это маяк на берегу для команды судов программистов. Когда кто‑то меняет код, маяки (тесты) показывают, не столкнётся ли корабль с рифом. Чем больше и точнее маяков, тем безопаснее плавание.",
    "Наконец, цель тестирования — не получить 100% покрытия любым путём, а иметь понятные, быстрые и надёжные тесты, которые защищают критические свойства программы и облегчают рефакторинг."
  ],
  "example": "import unittest\nfrom mymodule import add, divide\n\nclass TestMath(unittest.TestCase):\n    def test_add(self):\n        self.assertEqual(add(2, 3), 5)\n\n    def test_divide_by_zero(self):\n        with self.assertRaises(ZeroDivisionError):\n            divide(1, 0)\n\nif __name__ == '__main__':\n    unittest.main()\n\n# Пример с pytest\nimport pytest\nfrom mymodule import add, divide\n\ndef test_add():\n    assert add(2, 3) == 5\n\ndef test_divide_by_zero():\n    with pytest.raises(ZeroDivisionError):\n        divide(1, 0)\n\n# Параметризация в pytest\n@pytest.mark.parametrize('a,b,expected', [\n    (1, 1, 2),\n    (2, 3, 5),\n    (0, 5, 5),\n])\ndef test_add_param(a, b, expected):\n    assert add(a, b) == expected\n\n# Фикстура в pytest\n@pytest.fixture\ndef temp_file(tmp_path):\n    p = tmp_path / 'data.txt'\n    p.write_text('hello')\n    return p\n\ndef test_read_file(temp_file):\n    assert temp_file.read_text() == 'hello'",
  "notes": [
    {
      "hint": "Пиши маленькие, атомарные тесты: каждый тест проверяет один аспект поведения."
    },
    {
      "hint": "Держи тесты быстрыми: медленные тесты тормозят разработку и реже запускаются."
    },
    {
      "hint": "Используй фикстуры для подготовки и очистки контекста: это делает тесты читаемее и сокращает дублирование."
    },
    {
      "hint": "Моки применяй для изоляции от внешних зависимостей; избегай чрезмерного мокирования логики, которую лучше протестировать интеграционно."
    },
    {
      "hint": "Параметризуй тесты вместо написания похожих функций с разными данными."
    },
    {
      "hint": "Запускай тесты локально перед коммитом и интегрируй их в CI для автоматической проверки на каждом пуше."
    },
    {
      "hint": "Покрытие кода (coverage) полезно для нахождения непроверенных мест, но не заменяет здравый смысл при выборе того, что тестировать."
    },
    {
      "hint": "Документируй нестандартные сценарии в тестах: почему выбран конкретный набор данных или почему ожидается исключение."
    }
  ]
}
