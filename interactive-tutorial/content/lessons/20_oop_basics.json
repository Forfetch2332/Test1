{
  "title": "ООП: классы, объекты, наследование",
  "summary": "Введение в объектно‑ориентированное программирование на Python: определение классов, создание объектов, атрибуты, методы, инкапсуляция, наследование и переопределение поведения.",
  "text": [
    "Объектно‑ориентированное программирование (ООП) позволяет структурировать код вокруг объектов — сущностей, которые объединяют данные и поведение. В Python класс — это чертёж, а объект (экземпляр) — уже построенный по этому чертежу будинок.",
    "Класс объявляется с помощью ключевого слова class. Внутри класса определяются атрибуты (данные) и методы (функции, оперирующие данными). Пример простого класса: class Person: def __init__(self, name): self.name = name.",
    "Метод __init__ — конструктор: он вызывается при создании нового объекта и обычно инициализирует состояние (атрибуты) экземпляра. Атрибуты, присвоенные через self, принадлежат конкретному объекту.",
    "Атрибуты бывают экземплярными (хранятся в self) и статическими/классовыми (общие для всех экземпляров). Классовые атрибуты объявляют внутри тела класса вне методов и используются для данных, разделяемых всеми объектами.",
    "Инкапсуляция — идея скрывать внутреннее состояние и предоставлять интерфейс для безопасной работы с ним. В Python нет жёсткого закрытия полей, но принято использовать один подчёркивание _attr как подсказку для разработчиков и двойное подчёркивание __attr для механизма манглинга имён.",
    "Методы — обычные функции внутри класса. Первый параметр метода экземпляра обычно называется self и ссылается на сам объект. Статические методы (@staticmethod) и методы класса (@classmethod) имеют другие сигнатуры и применяются в отдельных сценариях.",
    "Наследование позволяет создавать новый класс на базе существующего: дочерний класс получает атрибуты и методы родителя и может добавлять или переопределять поведение. Синтаксис: class Student(Person): ... . Это основной механизм повторного использования кода и полиморфизма.",
    "Переопределение (override) — когда дочерний класс даёт свою реализацию метода родителя. Часто внутри переопределённого метода полезно вызвать метод родителя через super(): super().method(args).",
    "Полиморфизм означает, что разные объекты могут реагировать на одинаковые сообщения (вызовы методов) по‑разному. Это упрощает написание обобщённого кода: функция работает с любым объектом, реализующим ожидаемый интерфейс.",
    "Деструкторы в Python встречаются редко; специальный метод __del__ вызывается при удалении объекта, но полагаться на его вызов небезопасно. Для управления ресурсами чаще применяют контекстные менеджеры и протокол with.",
    "Художественный образ: представь класс как чертёж корабля, методы — как инструкции экипажа, а объекты — как реальные корабли, плавающие по разным морям. Наследование — это когда новый класс корабля наследует базовый корпус и добавляет свой парус или орудие."
  ],
  "example": "class Person:\n    species = 'Homo sapiens'  # классовый атрибут\n\n    def __init__(self, name, age):\n        self.name = name        # атрибут экземпляра\n        self.age = age\n\n    def greet(self):\n        return f\"Привет, меня зовут {self.name}, мне {self.age} лет\"\n\n    def birthday(self):\n        self.age += 1\n        return self.age\n\n# Наследование и переопределение\nclass Student(Person):\n    def __init__(self, name, age, university):\n        super().__init__(name, age)\n        self.university = university\n\n    def greet(self):\n        base = super().greet()\n        return base + f\", и я учусь в {self.university}\"\n\n# Пример контекстного менеджера внутри класса\nclass Resource:\n    def __init__(self, name):\n        self.name = name\n        self.opened = False\n\n    def __enter__(self):\n        self.opened = True\n        print(f\"Ресурс {self.name} открыт\")\n        return self\n\n    def __exit__(self, exc_type, exc, tb):\n        self.opened = False\n        print(f\"Ресурс {self.name} закрыт\")\n        return False  # не подавляем исключения\n\n# Статический метод и метод класса\nclass MathUtils:\n    @staticmethod\n    def add(a, b):\n        return a + b\n\n    @classmethod\n    def describe(cls):\n        return f\"Утилиты для класса {cls.__name__}\"\n\n# Использование\np = Person('Анна', 30)\ns = Student('Максим', 22, 'БГУ')\nprint(p.greet())\nprint(s.greet())\nprint('Возраст до дня рождения:', s.age)\ns.birthday()\nprint('Возраст после дня рождения:', s.age)\n\nprint(MathUtils.add(2, 3))\nprint(MathUtils.describe())\n\nwith Resource('DB') as r:\n    print('Работаем с ресурсом, открыт ли он?', r.opened)\n\n# Демонстрация полиморфизма\ndef say_hello(entity):\n    print(entity.greet())\n\nsay_hello(p)\nsay_hello(s)\n",
  "notes": [
    {
      "hint": "Используй __init__ для инициализации состояния экземпляра; self указывает на текущий объект."
    },
    {
      "hint": "Классовые атрибуты общие для всех экземпляров; экземплярные атрибуты уникальны для каждого объекта."
    },
    {
      "hint": "Применяй super() при переопределении методов, чтобы корректно вызывать поведение родителя и избежать дублирования кода."
    },
    {
      "hint": "Для 'закрытых' полей используй соглашения _имя и __имя; манглинг __имя делает прямой доступ из вне менее удобным."
    },
    {
      "hint": "Статические методы не получают self или cls; методы класса получают cls и полезны для создания альтернативных конструкторов."
    },
    {
      "hint": "ООП хорошо подходит для моделирования предметной области, но не злоупотребляй: для простых задач часто достаточно функций и модулей."
    },
    {
      "hint": "Пиши небольшие, сфокусированные классы с явным интерфейсом — это облегчает тестирование и повторное использование."
    },
    {
      "hint": "Для управления ресурсами внутри класса реализуй контекстный менеджер (__enter__/__exit__) вместо полагания на __del__."
    }
  ]
}
